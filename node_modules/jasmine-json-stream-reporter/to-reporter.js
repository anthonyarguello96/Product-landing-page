'use strict';

var _require = require('through2'),
    through = _require.obj;

function handleFailures(failures, onError) {
  this.emit('error', onError(failures + ' ' + (failures === 1 ? 'failure' : 'failures')));
}

function noop() {}

module.exports = function (reporters) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!Array.isArray(reporters)) reporters = [reporters];
  var _options$onError = options.onError,
      onError = _options$onError === undefined ? function (message) {
    return new Error(message);
  } : _options$onError,
      _options$onConsoleMes = options.onConsoleMessage,
      onConsoleMessage = _options$onConsoleMes === undefined ? noop : _options$onConsoleMes,
      _options$onCoverage = options.onCoverage,
      onCoverage = _options$onCoverage === undefined ? noop : _options$onCoverage,
      _options$onSnapshot = options.onSnapshot,
      onSnapshot = _options$onSnapshot === undefined ? noop : _options$onSnapshot;

  var failures = 0;

  function specDone(chunk) {
    if (chunk.status === 'failed') failures++;
  }

  function consoleMessage(_ref) {
    var message = _ref.message;

    reporters.forEach(function (reporter) {
      return reporter.print && reporter.print(message);
    });
    onConsoleMessage(message);
  }

  function coverage(_ref2) {
    var coverage = _ref2.coverage;

    onCoverage(coverage);
  }

  function snapshot(_ref3) {
    var snapshot = _ref3.snapshot;

    onSnapshot(snapshot);
  }

  var events = { specStarted: true, specDone: specDone, suiteStarted: true, suiteDone: true, jasmineStarted: true, jasmineDone: true, consoleMessage: consoleMessage, coverage: coverage, snapshot: snapshot };
  return through(function (chunk, enc, next) {
    Object.keys(events).find(function (key) {
      var value = events[key];
      if (!chunk.id.endsWith(':' + key)) return false;
      if (typeof value === 'function') value(chunk);
      reporters.forEach(function (reporter) {
        return key in reporter && reporter[key](chunk);
      });
      return true;
    });
    next(null, chunk);
  }, function (flush) {
    reporters.forEach(function (reporter) {
      return reporter.jasmineDone();
    });
    if (failures) handleFailures.call(this, failures, onError);
    flush();
  });
};